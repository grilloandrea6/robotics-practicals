   1              		.cpu arm7tdmi
   2              		.arch armv4t
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.file	"modes.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.align	2
  18              		.global	motor_demo_mode
  19              		.syntax unified
  20              		.arm
  22              	motor_demo_mode:
  23              	.LFB0:
  24              		.file 1 "modes.c"
   1:modes.c       **** #include "config.h"
   2:modes.c       **** #include "modes.h"
   3:modes.c       **** #include "robot.h"
   4:modes.c       **** #include "module.h"
   5:modes.c       **** #include "registers.h"
   6:modes.c       **** #include "hardware.h"
   7:modes.c       **** 
   8:modes.c       **** const uint8_t MOTOR_ADDR = 21;
   9:modes.c       **** 
  10:modes.c       **** void motor_demo_mode()
  11:modes.c       **** {
  25              		.loc 1 11 1 view -0
  26              		.cfi_startproc
  27              		@ Function supports interworking.
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  12:modes.c       ****   init_body_module(MOTOR_ADDR);
  30              		.loc 1 12 3 view .LVU1
  11:modes.c       ****   init_body_module(MOTOR_ADDR);
  31              		.loc 1 11 1 is_stmt 0 view .LVU2
  32 0000 70402DE9 		push	{r4, r5, r6, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 16
  35              		.cfi_offset 4, -16
  36              		.cfi_offset 5, -12
  37              		.cfi_offset 6, -8
  38              		.cfi_offset 14, -4
  39              		.loc 1 12 3 view .LVU3
  40 0004 1500A0E3 		mov	r0, #21
  41 0008 FEFFFFEB 		bl	init_body_module
  42              	.LVL0:
  13:modes.c       ****   start_pid(MOTOR_ADDR);
  43              		.loc 1 13 3 is_stmt 1 view .LVU4
  44 000c 1500A0E3 		mov	r0, #21
  45 0010 FEFFFFEB 		bl	start_pid
  46              	.LVL1:
  14:modes.c       ****   set_color(4);
  47              		.loc 1 14 3 view .LVU5
  48 0014 0400A0E3 		mov	r0, #4
  49 0018 FEFFFFEB 		bl	set_color
  50              	.LVL2:
  15:modes.c       ****   while (reg8_table[REG8_MODE] == IMODE_MOTOR_DEMO) {
  51              		.loc 1 15 3 view .LVU6
  52              		.loc 1 15 20 is_stmt 0 view .LVU7
  53 001c 78509FE5 		ldr	r5, .L5
  16:modes.c       ****     bus_set(MOTOR_ADDR, MREG_SETPOINT, DEG_TO_OUTPUT_BODY(21.0));
  17:modes.c       ****     pause(ONE_SEC);
  54              		.loc 1 17 5 view .LVU8
  55 0020 78409FE5 		ldr	r4, .L5+4
  56              	.L2:
  15:modes.c       ****   while (reg8_table[REG8_MODE] == IMODE_MOTOR_DEMO) {
  57              		.loc 1 15 9 is_stmt 1 view .LVU9
  15:modes.c       ****   while (reg8_table[REG8_MODE] == IMODE_MOTOR_DEMO) {
  58              		.loc 1 15 20 is_stmt 0 view .LVU10
  59 0024 0030D5E5 		ldrb	r3, [r5]	@ zero_extendqisi2
  15:modes.c       ****   while (reg8_table[REG8_MODE] == IMODE_MOTOR_DEMO) {
  60              		.loc 1 15 9 view .LVU11
  61 0028 010053E3 		cmp	r3, #1
  62 002c 0D00000A 		beq	.L3
  18:modes.c       ****     bus_set(MOTOR_ADDR, MREG_SETPOINT, DEG_TO_OUTPUT_BODY(-21.0));
  19:modes.c       ****     pause(ONE_SEC);
  20:modes.c       ****   }
  21:modes.c       ****   bus_set(MOTOR_ADDR, MREG_SETPOINT, DEG_TO_OUTPUT_BODY(0.0));
  63              		.loc 1 21 3 is_stmt 1 view .LVU12
  64 0030 0020A0E3 		mov	r2, #0
  65 0034 2F10A0E3 		mov	r1, #47
  66 0038 1500A0E3 		mov	r0, #21
  67 003c FEFFFFEB 		bl	bus_set
  68              	.LVL3:
  22:modes.c       ****   pause(ONE_SEC);
  69              		.loc 1 22 3 view .LVU13
  70 0040 58009FE5 		ldr	r0, .L5+4
  71 0044 FEFFFFEB 		bl	pause
  72              	.LVL4:
  23:modes.c       ****   bus_set(MOTOR_ADDR, MREG_MODE, MODE_IDLE);
  73              		.loc 1 23 3 view .LVU14
  74 0048 0020A0E3 		mov	r2, #0
  75 004c 2810A0E3 		mov	r1, #40
  76 0050 1500A0E3 		mov	r0, #21
  77 0054 FEFFFFEB 		bl	bus_set
  78              	.LVL5:
  24:modes.c       ****   set_color(2);
  79              		.loc 1 24 3 view .LVU15
  80 0058 0200A0E3 		mov	r0, #2
  81 005c FEFFFFEB 		bl	set_color
  82              	.LVL6:
  25:modes.c       **** }
  83              		.loc 1 25 1 is_stmt 0 view .LVU16
  84 0060 7040BDE8 		pop	{r4, r5, r6, lr}
  85              	.LCFI1:
  86              		.cfi_remember_state
  87              		.cfi_restore 14
  88              		.cfi_restore 6
  89              		.cfi_restore 5
  90              		.cfi_restore 4
  91              		.cfi_def_cfa_offset 0
  92 0064 1EFF2FE1 		bx	lr
  93              	.L3:
  94              	.LCFI2:
  95              		.cfi_restore_state
  16:modes.c       ****     pause(ONE_SEC);
  96              		.loc 1 16 5 is_stmt 1 view .LVU17
  97 0068 1F20A0E3 		mov	r2, #31
  98 006c 2F10A0E3 		mov	r1, #47
  99 0070 1500A0E3 		mov	r0, #21
 100 0074 FEFFFFEB 		bl	bus_set
 101              	.LVL7:
  17:modes.c       ****     bus_set(MOTOR_ADDR, MREG_SETPOINT, DEG_TO_OUTPUT_BODY(-21.0));
 102              		.loc 1 17 5 view .LVU18
 103 0078 0400A0E1 		mov	r0, r4
 104 007c FEFFFFEB 		bl	pause
 105              	.LVL8:
  18:modes.c       ****     pause(ONE_SEC);
 106              		.loc 1 18 5 view .LVU19
 107 0080 E120A0E3 		mov	r2, #225
 108 0084 2F10A0E3 		mov	r1, #47
 109 0088 1500A0E3 		mov	r0, #21
 110 008c FEFFFFEB 		bl	bus_set
 111              	.LVL9:
  19:modes.c       ****   }
 112              		.loc 1 19 5 view .LVU20
 113 0090 0400A0E1 		mov	r0, r4
 114 0094 FEFFFFEB 		bl	pause
 115              	.LVL10:
 116 0098 E1FFFFEA 		b	.L2
 117              	.L6:
 118              		.align	2
 119              	.L5:
 120 009c 00000000 		.word	reg8_table
 121 00a0 80969800 		.word	10000000
 122              		.cfi_endproc
 123              	.LFE0:
 125              		.align	2
 126              		.global	main_mode_loop
 127              		.syntax unified
 128              		.arm
 130              	main_mode_loop:
 131              	.LFB1:
  26:modes.c       **** 
  27:modes.c       **** void main_mode_loop()
  28:modes.c       **** {
 132              		.loc 1 28 1 view -0
 133              		.cfi_startproc
 134              		@ Function supports interworking.
 135              		@ Volatile: function does not return.
 136              		@ args = 0, pretend = 0, frame = 0
 137              		@ frame_needed = 0, uses_anonymous_args = 0
  29:modes.c       ****   reg8_table[REG8_MODE] = IMODE_IDLE;
 138              		.loc 1 29 3 view .LVU22
 139              		.loc 1 29 25 is_stmt 0 view .LVU23
 140 00a4 0050A0E3 		mov	r5, #0
  28:modes.c       ****   reg8_table[REG8_MODE] = IMODE_IDLE;
 141              		.loc 1 28 1 view .LVU24
 142 00a8 10402DE9 		push	{r4, lr}
 143              	.LCFI3:
 144              		.cfi_def_cfa_offset 8
 145              		.cfi_offset 4, -8
 146              		.cfi_offset 14, -4
 147              		.loc 1 29 25 view .LVU25
 148 00ac 1C409FE5 		ldr	r4, .L16
 149              	.L15:
 150 00b0 0050C4E5 		strb	r5, [r4]
 151              	.L9:
  30:modes.c       **** 
  31:modes.c       ****   while (1)
 152              		.loc 1 31 3 is_stmt 1 view .LVU26
  32:modes.c       ****   {
  33:modes.c       ****     switch(reg8_table[REG8_MODE])
 153              		.loc 1 33 5 view .LVU27
 154              		.loc 1 33 22 is_stmt 0 view .LVU28
 155 00b4 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 156              		.loc 1 33 5 view .LVU29
 157 00b8 FF3013E2 		ands	r3, r3, #255
 158 00bc FCFFFF0A 		beq	.L9
 159 00c0 010053E3 		cmp	r3, #1
 160 00c4 F9FFFF1A 		bne	.L15
  34:modes.c       ****     {
  35:modes.c       ****       case IMODE_IDLE:
  36:modes.c       ****         break;
  37:modes.c       ****       case IMODE_MOTOR_DEMO:
  38:modes.c       ****         motor_demo_mode();
 161              		.loc 1 38 9 is_stmt 1 view .LVU30
 162 00c8 FEFFFFEB 		bl	motor_demo_mode
 163              	.LVL11:
  39:modes.c       ****         break;
 164              		.loc 1 39 9 view .LVU31
 165 00cc F8FFFFEA 		b	.L9
 166              	.L17:
 167              		.align	2
 168              	.L16:
 169 00d0 00000000 		.word	reg8_table
 170              		.cfi_endproc
 171              	.LFE1:
 173              		.global	MOTOR_ADDR
 174              		.section	.rodata
 177              	MOTOR_ADDR:
 178 0000 15       		.byte	21
 179              		.text
 180              	.Letext0:
 181              		.file 2 "c:\\arm-gcc\\arm-none-eabi\\include\\machine\\_default_types.h"
 182              		.file 3 "c:\\arm-gcc\\arm-none-eabi\\include\\sys\\_stdint.h"
 183              		.file 4 "../firmware/registers.h"
 184              		.file 5 "../firmware/robot.h"
 185              		.file 6 "../firmware/hardware.h"
 186              		.file 7 "../firmware/sysTime.h"
 187              		.file 8 "../../common/regdefs.h"
DEFINED SYMBOLS
                            *ABS*:00000000 modes.c
C:\Users\agrillo\AppData\Local\Temp\cciLpBtl.s:17     .text:00000000 $a
C:\Users\agrillo\AppData\Local\Temp\cciLpBtl.s:22     .text:00000000 motor_demo_mode
C:\Users\agrillo\AppData\Local\Temp\cciLpBtl.s:120    .text:0000009c $d
C:\Users\agrillo\AppData\Local\Temp\cciLpBtl.s:125    .text:000000a4 $a
C:\Users\agrillo\AppData\Local\Temp\cciLpBtl.s:130    .text:000000a4 main_mode_loop
C:\Users\agrillo\AppData\Local\Temp\cciLpBtl.s:169    .text:000000d0 $d
C:\Users\agrillo\AppData\Local\Temp\cciLpBtl.s:177    .rodata:00000000 MOTOR_ADDR

UNDEFINED SYMBOLS
init_body_module
start_pid
set_color
bus_set
pause
reg8_table
