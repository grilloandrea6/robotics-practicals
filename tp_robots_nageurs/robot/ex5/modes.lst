   1              		.cpu arm7tdmi
   2              		.arch armv4t
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.file	"modes.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.global	__aeabi_ui2f
  18              		.global	__aeabi_fdiv
  19              		.global	__aeabi_fadd
  20              		.global	__aeabi_f2d
  21              		.global	__aeabi_dmul
  22              		.global	__aeabi_d2f
  23              		.global	__aeabi_f2iz
  24              		.global	__aeabi_i2f
  25              		.global	__aeabi_fmul
  26              		.align	2
  27              		.global	sine_demo_mode
  28              		.syntax unified
  29              		.arm
  31              	sine_demo_mode:
  32              	.LFB0:
  33              		.file 1 "modes.c"
   1:modes.c       **** #include "config.h"
   2:modes.c       **** #include "modes.h"
   3:modes.c       **** #include "robot.h"
   4:modes.c       **** #include "module.h"
   5:modes.c       **** #include "registers.h"
   6:modes.c       **** #include "hardware.h"
   7:modes.c       **** 
   8:modes.c       **** const float FREQ = 1.0;   // Hz
   9:modes.c       **** const uint8_t MOTOR_ADDR = 21;
  10:modes.c       **** 
  11:modes.c       **** void sine_demo_mode()
  12:modes.c       **** {
  34              		.loc 1 12 1 view -0
  35              		.cfi_startproc
  36              		@ Function supports interworking.
  37              		@ args = 0, pretend = 0, frame = 0
  38              		@ frame_needed = 0, uses_anonymous_args = 0
  13:modes.c       ****   uint32_t dt, cycletimer;
  39              		.loc 1 13 3 view .LVU1
  14:modes.c       ****   float my_time, delta_t, l;
  40              		.loc 1 14 3 view .LVU2
  15:modes.c       ****   int8_t l_rounded;
  41              		.loc 1 15 3 view .LVU3
  16:modes.c       **** 
  17:modes.c       ****   cycletimer = getSysTICs();
  42              		.loc 1 17 3 view .LVU4
  12:modes.c       ****   uint32_t dt, cycletimer;
  43              		.loc 1 12 1 is_stmt 0 view .LVU5
  44 0000 F84F2DE9 		push	{r3, r4, r5, r6, r7, r8, r9, r10, fp, lr}
  45              	.LCFI0:
  46              		.cfi_def_cfa_offset 40
  47              		.cfi_offset 3, -40
  48              		.cfi_offset 4, -36
  49              		.cfi_offset 5, -32
  50              		.cfi_offset 6, -28
  51              		.cfi_offset 7, -24
  52              		.cfi_offset 8, -20
  53              		.cfi_offset 9, -16
  54              		.cfi_offset 10, -12
  55              		.cfi_offset 11, -8
  56              		.cfi_offset 14, -4
  57              		.loc 1 17 16 view .LVU6
  58 0004 FEFFFFEB 		bl	getSysTICs
  59              	.LVL0:
  60 0008 0040A0E1 		mov	r4, r0
  61              	.LVL1:
  18:modes.c       ****   my_time = 0;
  62              		.loc 1 18 3 is_stmt 1 view .LVU7
  19:modes.c       **** 
  20:modes.c       ****   init_body_module(MOTOR_ADDR);
  63              		.loc 1 20 3 view .LVU8
  64 000c 1500A0E3 		mov	r0, #21
  65              	.LVL2:
  66              		.loc 1 20 3 is_stmt 0 view .LVU9
  67 0010 FEFFFFEB 		bl	init_body_module
  68              	.LVL3:
  21:modes.c       ****   start_pid(MOTOR_ADDR);
  69              		.loc 1 21 3 is_stmt 1 view .LVU10
  70 0014 1500A0E3 		mov	r0, #21
  71 0018 FEFFFFEB 		bl	start_pid
  72              	.LVL4:
  22:modes.c       ****   set_color(4);
  73              		.loc 1 22 3 view .LVU11
  74 001c 0400A0E3 		mov	r0, #4
  75 0020 FEFFFFEB 		bl	set_color
  76              	.LVL5:
  18:modes.c       **** 
  77              		.loc 1 18 11 is_stmt 0 view .LVU12
  78 0024 0050A0E3 		mov	r5, #0
  23:modes.c       ****   do {
  24:modes.c       ****     // Calculates the delta_t in seconds and adds it to the current time
  25:modes.c       ****     dt = getElapsedSysTICs(cycletimer);
  26:modes.c       ****     cycletimer = getSysTICs();
  27:modes.c       ****     delta_t = (float) dt / sysTICSperSEC;
  28:modes.c       ****     my_time += delta_t;
  29:modes.c       **** 
  30:modes.c       ****     // Calculates the sine wave
  31:modes.c       ****     l = 40 * sin(M_TWOPI * FREQ * my_time);
  79              		.loc 1 31 12 view .LVU13
  80 0028 0060A0E3 		mov	r6, #0
  27:modes.c       ****     my_time += delta_t;
  81              		.loc 1 27 13 view .LVU14
  82 002c DCB09FE5 		ldr	fp, .L6
  83              		.loc 1 31 14 view .LVU15
  84 0030 DC809FE5 		ldr	r8, .L6+4
  85 0034 DC909FE5 		ldr	r9, .L6+8
  86              		.loc 1 31 12 view .LVU16
  87 0038 DC709FE5 		ldr	r7, .L6+12
  88              	.LVL6:
  89              	.L2:
  23:modes.c       ****   do {
  90              		.loc 1 23 3 is_stmt 1 discriminator 1 view .LVU17
  25:modes.c       ****     cycletimer = getSysTICs();
  91              		.loc 1 25 5 discriminator 1 view .LVU18
  25:modes.c       ****     cycletimer = getSysTICs();
  92              		.loc 1 25 10 is_stmt 0 discriminator 1 view .LVU19
  93 003c 0400A0E1 		mov	r0, r4
  94 0040 FEFFFFEB 		bl	getElapsedSysTICs
  95              	.LVL7:
  96 0044 00A0A0E1 		mov	r10, r0
  97              	.LVL8:
  26:modes.c       ****     delta_t = (float) dt / sysTICSperSEC;
  98              		.loc 1 26 5 is_stmt 1 discriminator 1 view .LVU20
  26:modes.c       ****     delta_t = (float) dt / sysTICSperSEC;
  99              		.loc 1 26 18 is_stmt 0 discriminator 1 view .LVU21
 100 0048 FEFFFFEB 		bl	getSysTICs
 101              	.LVL9:
  26:modes.c       ****     delta_t = (float) dt / sysTICSperSEC;
 102              		.loc 1 26 18 discriminator 1 view .LVU22
 103 004c 0040A0E1 		mov	r4, r0
 104              	.LVL10:
  27:modes.c       ****     my_time += delta_t;
 105              		.loc 1 27 5 is_stmt 1 discriminator 1 view .LVU23
  28:modes.c       **** 
 106              		.loc 1 28 5 discriminator 1 view .LVU24
  27:modes.c       ****     my_time += delta_t;
 107              		.loc 1 27 15 is_stmt 0 discriminator 1 view .LVU25
 108 0050 0A00A0E1 		mov	r0, r10
 109              	.LVL11:
  27:modes.c       ****     my_time += delta_t;
 110              		.loc 1 27 15 discriminator 1 view .LVU26
 111 0054 FEFFFFEB 		bl	__aeabi_ui2f
 112              	.LVL12:
  27:modes.c       ****     my_time += delta_t;
 113              		.loc 1 27 13 discriminator 1 view .LVU27
 114 0058 0B10A0E1 		mov	r1, fp
 115 005c FEFFFFEB 		bl	__aeabi_fdiv
 116              	.LVL13:
 117 0060 0010A0E1 		mov	r1, r0
  28:modes.c       **** 
 118              		.loc 1 28 13 discriminator 1 view .LVU28
 119 0064 0500A0E1 		mov	r0, r5
 120 0068 FEFFFFEB 		bl	__aeabi_fadd
 121              	.LVL14:
 122 006c 0050A0E1 		mov	r5, r0
 123              	.LVL15:
 124              		.loc 1 31 5 is_stmt 1 discriminator 1 view .LVU29
 125              		.loc 1 31 14 is_stmt 0 discriminator 1 view .LVU30
 126 0070 FEFFFFEB 		bl	__aeabi_f2d
 127              	.LVL16:
 128              		.loc 1 31 14 discriminator 1 view .LVU31
 129 0074 0820A0E1 		mov	r2, r8
 130 0078 0930A0E1 		mov	r3, r9
 131 007c FEFFFFEB 		bl	__aeabi_dmul
 132              	.LVL17:
 133 0080 FEFFFFEB 		bl	sin
 134              	.LVL18:
  32:modes.c       ****     l_rounded = (int8_t) l;
 135              		.loc 1 32 5 is_stmt 1 discriminator 1 view .LVU32
  33:modes.c       **** 
  34:modes.c       ****     bus_set(MOTOR_ADDR, MREG_SETPOINT, DEG_TO_OUTPUT_BODY(l_rounded));
 136              		.loc 1 34 5 discriminator 1 view .LVU33
  31:modes.c       ****     l_rounded = (int8_t) l;
 137              		.loc 1 31 12 is_stmt 0 discriminator 1 view .LVU34
 138 0084 0730A0E1 		mov	r3, r7
 139 0088 0620A0E1 		mov	r2, r6
 140 008c FEFFFFEB 		bl	__aeabi_dmul
 141              	.LVL19:
  31:modes.c       ****     l_rounded = (int8_t) l;
 142              		.loc 1 31 7 discriminator 1 view .LVU35
 143 0090 FEFFFFEB 		bl	__aeabi_d2f
 144              	.LVL20:
  32:modes.c       ****     l_rounded = (int8_t) l;
 145              		.loc 1 32 15 discriminator 1 view .LVU36
 146 0094 FEFFFFEB 		bl	__aeabi_f2iz
 147              	.LVL21:
 148              		.loc 1 34 40 discriminator 1 view .LVU37
 149 0098 000CA0E1 		lsl	r0, r0, #24
 150 009c 400CA0E1 		asr	r0, r0, #24
 151 00a0 FEFFFFEB 		bl	__aeabi_i2f
 152              	.LVL22:
 153 00a4 FF15A0E3 		mov	r1, #1069547520
 154 00a8 FEFFFFEB 		bl	__aeabi_fmul
 155              	.LVL23:
 156 00ac FEFFFFEB 		bl	__aeabi_f2iz
 157              	.LVL24:
 158              		.loc 1 34 5 discriminator 1 view .LVU38
 159 00b0 2F10A0E3 		mov	r1, #47
 160 00b4 FF2000E2 		and	r2, r0, #255
 161 00b8 1500A0E3 		mov	r0, #21
 162 00bc FEFFFFEB 		bl	bus_set
 163              	.LVL25:
  35:modes.c       ****     
  36:modes.c       ****     // Make sure there is some delay, so that the timer output is not zero
  37:modes.c       ****     pause(ONE_MS);
 164              		.loc 1 37 5 is_stmt 1 discriminator 1 view .LVU39
 165 00c0 58009FE5 		ldr	r0, .L6+16
 166 00c4 FEFFFFEB 		bl	pause
 167              	.LVL26:
  38:modes.c       ****   } while (reg8_table[REG8_MODE] == IMODE_SINE_DEMO);
 168              		.loc 1 38 11 discriminator 1 view .LVU40
 169              		.loc 1 38 22 is_stmt 0 discriminator 1 view .LVU41
 170 00c8 54309FE5 		ldr	r3, .L6+20
 171 00cc 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 172              		.loc 1 38 3 discriminator 1 view .LVU42
 173 00d0 020053E3 		cmp	r3, #2
 174 00d4 D8FFFF0A 		beq	.L2
  39:modes.c       ****   bus_set(MOTOR_ADDR, MREG_SETPOINT, DEG_TO_OUTPUT_BODY(0.0));
 175              		.loc 1 39 3 is_stmt 1 view .LVU43
 176 00d8 0020A0E3 		mov	r2, #0
 177 00dc 2F10A0E3 		mov	r1, #47
 178 00e0 1500A0E3 		mov	r0, #21
 179 00e4 FEFFFFEB 		bl	bus_set
 180              	.LVL27:
  40:modes.c       ****   pause(ONE_SEC);
 181              		.loc 1 40 3 view .LVU44
 182 00e8 38009FE5 		ldr	r0, .L6+24
 183 00ec FEFFFFEB 		bl	pause
 184              	.LVL28:
  41:modes.c       ****   bus_set(MOTOR_ADDR, MREG_MODE, MODE_IDLE);
 185              		.loc 1 41 3 view .LVU45
 186 00f0 0020A0E3 		mov	r2, #0
 187 00f4 2810A0E3 		mov	r1, #40
 188 00f8 1500A0E3 		mov	r0, #21
 189 00fc FEFFFFEB 		bl	bus_set
 190              	.LVL29:
  42:modes.c       ****   // Back to the "normal" green
  43:modes.c       ****   set_color(2);
 191              		.loc 1 43 3 view .LVU46
 192 0100 0200A0E3 		mov	r0, #2
 193 0104 FEFFFFEB 		bl	set_color
 194              	.LVL30:
  44:modes.c       **** }
 195              		.loc 1 44 1 is_stmt 0 view .LVU47
 196 0108 F84FBDE8 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 197              	.LCFI1:
 198              		.cfi_restore 14
 199              		.cfi_restore 11
 200              		.cfi_restore 10
 201              		.cfi_restore 9
 202              		.cfi_restore 8
 203              		.cfi_restore 7
 204              		.cfi_restore 6
 205              		.cfi_restore 5
 206              		.cfi_restore 4
 207              		.cfi_restore 3
 208              		.cfi_def_cfa_offset 0
 209              	.LVL31:
 210              		.loc 1 44 1 view .LVU48
 211 010c 1EFF2FE1 		bx	lr
 212              	.L7:
 213              		.align	2
 214              	.L6:
 215 0110 8096184B 		.word	1259902592
 216 0114 182D4454 		.word	1413754136
 217 0118 FB211940 		.word	1075388923
 218 011c 00004440 		.word	1078198272
 219 0120 10270000 		.word	10000
 220 0124 00000000 		.word	reg8_table
 221 0128 80969800 		.word	10000000
 222              		.cfi_endproc
 223              	.LFE0:
 225              		.align	2
 226              		.global	main_mode_loop
 227              		.syntax unified
 228              		.arm
 230              	main_mode_loop:
 231              	.LFB1:
  45:modes.c       **** 
  46:modes.c       **** void main_mode_loop()
  47:modes.c       **** {
 232              		.loc 1 47 1 is_stmt 1 view -0
 233              		.cfi_startproc
 234              		@ Function supports interworking.
 235              		@ Volatile: function does not return.
 236              		@ args = 0, pretend = 0, frame = 0
 237              		@ frame_needed = 0, uses_anonymous_args = 0
  48:modes.c       ****   reg8_table[REG8_MODE] = IMODE_IDLE;
 238              		.loc 1 48 3 view .LVU50
 239              		.loc 1 48 25 is_stmt 0 view .LVU51
 240 012c 0050A0E3 		mov	r5, #0
  47:modes.c       ****   reg8_table[REG8_MODE] = IMODE_IDLE;
 241              		.loc 1 47 1 view .LVU52
 242 0130 10402DE9 		push	{r4, lr}
 243              	.LCFI2:
 244              		.cfi_def_cfa_offset 8
 245              		.cfi_offset 4, -8
 246              		.cfi_offset 14, -4
 247              		.loc 1 48 25 view .LVU53
 248 0134 1C409FE5 		ldr	r4, .L17
 249              	.L16:
 250 0138 0050C4E5 		strb	r5, [r4]
 251              	.L10:
  49:modes.c       **** 
  50:modes.c       ****   while (1)
 252              		.loc 1 50 3 is_stmt 1 view .LVU54
  51:modes.c       ****   {
  52:modes.c       ****     switch(reg8_table[REG8_MODE])
 253              		.loc 1 52 5 view .LVU55
 254              		.loc 1 52 22 is_stmt 0 view .LVU56
 255 013c 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 256              		.loc 1 52 5 view .LVU57
 257 0140 FF3013E2 		ands	r3, r3, #255
 258 0144 FCFFFF0A 		beq	.L10
 259 0148 020053E3 		cmp	r3, #2
 260 014c F9FFFF1A 		bne	.L16
  53:modes.c       ****     {
  54:modes.c       ****       case IMODE_IDLE:
  55:modes.c       ****         break;
  56:modes.c       ****       case IMODE_SINE_DEMO:
  57:modes.c       ****         sine_demo_mode();
 261              		.loc 1 57 9 is_stmt 1 view .LVU58
 262 0150 FEFFFFEB 		bl	sine_demo_mode
 263              	.LVL32:
  58:modes.c       ****         break;
 264              		.loc 1 58 9 view .LVU59
 265 0154 F8FFFFEA 		b	.L10
 266              	.L18:
 267              		.align	2
 268              	.L17:
 269 0158 00000000 		.word	reg8_table
 270              		.cfi_endproc
 271              	.LFE1:
 273              		.global	MOTOR_ADDR
 274              		.global	FREQ
 275              		.section	.rodata
 276              		.align	2
 279              	MOTOR_ADDR:
 280 0000 15       		.byte	21
 281 0001 000000   		.space	3
 284              	FREQ:
 285 0004 0000803F 		.word	1065353216
 286              		.text
 287              	.Letext0:
 288              		.file 2 "c:\\arm-gcc\\arm-none-eabi\\include\\machine\\_default_types.h"
 289              		.file 3 "c:\\arm-gcc\\arm-none-eabi\\include\\sys\\_stdint.h"
 290              		.file 4 "../firmware/registers.h"
 291              		.file 5 "../firmware/sysTime.h"
 292              		.file 6 "../firmware/robot.h"
 293              		.file 7 "../firmware/hardware.h"
 294              		.file 8 "../../common/regdefs.h"
 295              		.file 9 "c:\\arm-gcc\\arm-none-eabi\\include\\math.h"
DEFINED SYMBOLS
                            *ABS*:00000000 modes.c
C:\Users\agrillo\AppData\Local\Temp\ccHdPKma.s:26     .text:00000000 $a
C:\Users\agrillo\AppData\Local\Temp\ccHdPKma.s:31     .text:00000000 sine_demo_mode
C:\Users\agrillo\AppData\Local\Temp\ccHdPKma.s:215    .text:00000110 $d
C:\Users\agrillo\AppData\Local\Temp\ccHdPKma.s:225    .text:0000012c $a
C:\Users\agrillo\AppData\Local\Temp\ccHdPKma.s:230    .text:0000012c main_mode_loop
C:\Users\agrillo\AppData\Local\Temp\ccHdPKma.s:269    .text:00000158 $d
C:\Users\agrillo\AppData\Local\Temp\ccHdPKma.s:279    .rodata:00000000 MOTOR_ADDR
C:\Users\agrillo\AppData\Local\Temp\ccHdPKma.s:284    .rodata:00000004 FREQ
C:\Users\agrillo\AppData\Local\Temp\ccHdPKma.s:276    .rodata:00000000 $d

UNDEFINED SYMBOLS
__aeabi_ui2f
__aeabi_fdiv
__aeabi_fadd
__aeabi_f2d
__aeabi_dmul
__aeabi_d2f
__aeabi_f2iz
__aeabi_i2f
__aeabi_fmul
getSysTICs
init_body_module
start_pid
set_color
getElapsedSysTICs
sin
bus_set
pause
reg8_table
