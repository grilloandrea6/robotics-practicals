   1              		.cpu arm7tdmi
   2              		.arch armv4t
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.file	"modes.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.global	__aeabi_ui2f
  18              		.global	__aeabi_fmul
  19              		.global	__aeabi_f2d
  20              		.global	__aeabi_ddiv
  21              		.global	__aeabi_dsub
  22              		.align	2
  23              		.syntax unified
  24              		.arm
  26              	register_handler:
  27              	.LVL0:
  28              	.LFB0:
  29              		.file 1 "modes.c"
   1:modes.c       **** #include "config.h"
   2:modes.c       **** #include "modes.h"
   3:modes.c       **** #include "robot.h"
   4:modes.c       **** #include "module.h"
   5:modes.c       **** #include "registers.h"
   6:modes.c       **** #include "hardware.h"
   7:modes.c       **** 
   8:modes.c       **** const uint8_t MOTOR_ADDR = 21;
   9:modes.c       **** 
  10:modes.c       **** double setpoint = 0;
  11:modes.c       **** 
  12:modes.c       **** /* Register callback function, handles some new registers on the radio.
  13:modes.c       ****  * All these registers are of course completely useless, but it demonstrates how
  14:modes.c       ****  * to implement a register callback function, and what it can do.
  15:modes.c       ****  */
  16:modes.c       **** static int8_t register_handler(uint8_t operation, uint8_t address, RadioData* radio_data)
  17:modes.c       **** {
  30              		.loc 1 17 1 view -0
  31              		.cfi_startproc
  32              		@ Function supports interworking.
  33              		@ args = 0, pretend = 0, frame = 0
  34              		@ frame_needed = 0, uses_anonymous_args = 0
  18:modes.c       ****   if(operation == ROP_WRITE_8) {
  35              		.loc 1 18 3 view .LVU1
  19:modes.c       ****     if (address == 10) {
  36              		.loc 1 19 5 view .LVU2
  37              		.loc 1 19 8 is_stmt 0 view .LVU3
  38 0000 0A0051E3 		cmp	r1, #10
  39 0004 04005003 		cmpeq	r0, #4
  40 0008 0100A003 		moveq	r0, #1
  41              	.LVL1:
  42              		.loc 1 19 8 view .LVU4
  43 000c 0000A013 		movne	r0, #0
  44 0010 1EFF2F11 		bxne	lr
  45              	.LBB4:
  46              	.LBI4:
  16:modes.c       **** {
  47              		.loc 1 16 15 is_stmt 1 view .LVU5
  48              	.LVL2:
  49              	.LBB5:
  20:modes.c       ****       setpoint = DECODE_PARAM_8(radio_data->byte,(-50),(50));
  50              		.loc 1 20 7 view .LVU6
  51              	.LBE5:
  52              	.LBE4:
  17:modes.c       ****   if(operation == ROP_WRITE_8) {
  53              		.loc 1 17 1 is_stmt 0 view .LVU7
  54 0014 10402DE9 		push	{r4, lr}
  55              	.LCFI0:
  56              		.cfi_def_cfa_offset 8
  57              		.cfi_offset 4, -8
  58              		.cfi_offset 14, -4
  59              	.LBB8:
  60              	.LBB6:
  61              		.loc 1 20 18 view .LVU8
  62 0018 0000D2E5 		ldrb	r0, [r2]	@ zero_extendqisi2
  63 001c FEFFFFEB 		bl	__aeabi_ui2f
  64              	.LVL3:
  65              		.loc 1 20 18 view .LVU9
  66 0020 30109FE5 		ldr	r1, .L8
  67 0024 FEFFFFEB 		bl	__aeabi_fmul
  68              	.LVL4:
  69 0028 FEFFFFEB 		bl	__aeabi_f2d
  70              	.LVL5:
  71 002c 0020A0E3 		mov	r2, #0
  72 0030 24309FE5 		ldr	r3, .L8+4
  73 0034 FEFFFFEB 		bl	__aeabi_ddiv
  74              	.LVL6:
  75 0038 20309FE5 		ldr	r3, .L8+8
  76 003c 0020A0E3 		mov	r2, #0
  77 0040 FEFFFFEB 		bl	__aeabi_dsub
  78              	.LVL7:
  79              		.loc 1 20 16 view .LVU10
  80 0044 18309FE5 		ldr	r3, .L8+12
  81              	.LBE6:
  82              	.LBE8:
  21:modes.c       ****       return TRUE;
  22:modes.c       ****     }
  23:modes.c       ****   }
  24:modes.c       ****   return FALSE;
  25:modes.c       **** }
  83              		.loc 1 25 1 view .LVU11
  84 0048 1040BDE8 		pop	{r4, lr}
  85              	.LCFI1:
  86              		.cfi_restore 14
  87              		.cfi_restore 4
  88              		.cfi_def_cfa_offset 0
  89              	.LBB9:
  90              	.LBB7:
  20:modes.c       ****       return TRUE;
  91              		.loc 1 20 16 view .LVU12
  92 004c 030083E8 		stm	r3, {r0-r1}
  21:modes.c       ****       return TRUE;
  93              		.loc 1 21 7 is_stmt 1 view .LVU13
  94              	.LVL8:
  20:modes.c       ****       return TRUE;
  95              		.loc 1 20 16 is_stmt 0 view .LVU14
  96 0050 0100A0E3 		mov	r0, #1
  97              	.LBE7:
  98              	.LBE9:
  99              		.loc 1 25 1 view .LVU15
 100 0054 1EFF2FE1 		bx	lr
 101              	.L9:
 102              		.align	2
 103              	.L8:
 104 0058 0000C842 		.word	1120403456
 105 005c 00E06F40 		.word	1081073664
 106 0060 00004940 		.word	1078525952
 107 0064 00000000 		.word	.LANCHOR0
 108              		.cfi_endproc
 109              	.LFE0:
 111              		.global	__aeabi_dmul
 112              		.global	__aeabi_d2iz
 113              		.align	2
 114              		.global	motor_demo_mode
 115              		.syntax unified
 116              		.arm
 118              	motor_demo_mode:
 119              	.LFB1:
  26:modes.c       **** 
  27:modes.c       **** 
  28:modes.c       **** 
  29:modes.c       **** void motor_demo_mode()
  30:modes.c       **** {
 120              		.loc 1 30 1 is_stmt 1 view -0
 121              		.cfi_startproc
 122              		@ Function supports interworking.
 123              		@ args = 0, pretend = 0, frame = 0
 124              		@ frame_needed = 0, uses_anonymous_args = 0
  31:modes.c       ****   // Registers the register handler callback function
  32:modes.c       ****   radio_add_reg_callback(register_handler);
 125              		.loc 1 32 3 view .LVU17
  30:modes.c       ****   // Registers the register handler callback function
 126              		.loc 1 30 1 is_stmt 0 view .LVU18
 127 0068 F0412DE9 		push	{r4, r5, r6, r7, r8, lr}
 128              	.LCFI2:
 129              		.cfi_def_cfa_offset 24
 130              		.cfi_offset 4, -24
 131              		.cfi_offset 5, -20
 132              		.cfi_offset 6, -16
 133              		.cfi_offset 7, -12
 134              		.cfi_offset 8, -8
 135              		.cfi_offset 14, -4
 136              		.loc 1 32 3 view .LVU19
 137 006c 9C009FE5 		ldr	r0, .L14
 138 0070 FEFFFFEB 		bl	radio_add_reg_callback
 139              	.LVL9:
  33:modes.c       **** 
  34:modes.c       ****   init_body_module(MOTOR_ADDR);
 140              		.loc 1 34 3 is_stmt 1 view .LVU20
 141 0074 1500A0E3 		mov	r0, #21
 142 0078 FEFFFFEB 		bl	init_body_module
 143              	.LVL10:
  35:modes.c       ****   start_pid(MOTOR_ADDR);
 144              		.loc 1 35 3 view .LVU21
 145 007c 1500A0E3 		mov	r0, #21
 146 0080 FEFFFFEB 		bl	start_pid
 147              	.LVL11:
  36:modes.c       ****   set_color(4);
 148              		.loc 1 36 3 view .LVU22
 149 0084 0400A0E3 		mov	r0, #4
 150 0088 FEFFFFEB 		bl	set_color
 151              	.LVL12:
  37:modes.c       ****   while (reg8_table[REG8_MODE] == IMODE_MOTOR_DEMO) {
 152              		.loc 1 37 3 view .LVU23
  38:modes.c       ****     bus_set(MOTOR_ADDR, MREG_SETPOINT, DEG_TO_OUTPUT_BODY(setpoint));
 153              		.loc 1 38 40 is_stmt 0 view .LVU24
 154 008c 0060A0E3 		mov	r6, #0
  37:modes.c       ****   while (reg8_table[REG8_MODE] == IMODE_MOTOR_DEMO) {
 155              		.loc 1 37 20 view .LVU25
 156 0090 7C409FE5 		ldr	r4, .L14+4
 157              		.loc 1 38 40 view .LVU26
 158 0094 7C509FE5 		ldr	r5, .L14+8
 159 0098 7C709FE5 		ldr	r7, .L14+12
 160              	.L11:
  37:modes.c       ****   while (reg8_table[REG8_MODE] == IMODE_MOTOR_DEMO) {
 161              		.loc 1 37 9 is_stmt 1 view .LVU27
  37:modes.c       ****   while (reg8_table[REG8_MODE] == IMODE_MOTOR_DEMO) {
 162              		.loc 1 37 20 is_stmt 0 view .LVU28
 163 009c 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
  37:modes.c       ****   while (reg8_table[REG8_MODE] == IMODE_MOTOR_DEMO) {
 164              		.loc 1 37 9 view .LVU29
 165 00a0 010053E3 		cmp	r3, #1
 166 00a4 0D00000A 		beq	.L12
  39:modes.c       ****     pause(TEN_MS);
  40:modes.c       ****   }
  41:modes.c       ****   bus_set(MOTOR_ADDR, MREG_SETPOINT, DEG_TO_OUTPUT_BODY(0.0));
 167              		.loc 1 41 3 is_stmt 1 view .LVU30
 168 00a8 0020A0E3 		mov	r2, #0
 169 00ac 2F10A0E3 		mov	r1, #47
 170 00b0 1500A0E3 		mov	r0, #21
 171 00b4 FEFFFFEB 		bl	bus_set
 172              	.LVL13:
  42:modes.c       ****   pause(ONE_SEC);
 173              		.loc 1 42 3 view .LVU31
 174 00b8 60009FE5 		ldr	r0, .L14+16
 175 00bc FEFFFFEB 		bl	pause
 176              	.LVL14:
  43:modes.c       ****   bus_set(MOTOR_ADDR, MREG_MODE, MODE_IDLE);
 177              		.loc 1 43 3 view .LVU32
 178 00c0 0020A0E3 		mov	r2, #0
 179 00c4 2810A0E3 		mov	r1, #40
 180 00c8 1500A0E3 		mov	r0, #21
 181 00cc FEFFFFEB 		bl	bus_set
 182              	.LVL15:
  44:modes.c       ****   set_color(2);
 183              		.loc 1 44 3 view .LVU33
 184 00d0 0200A0E3 		mov	r0, #2
 185 00d4 FEFFFFEB 		bl	set_color
 186              	.LVL16:
  45:modes.c       **** }
 187              		.loc 1 45 1 is_stmt 0 view .LVU34
 188 00d8 F041BDE8 		pop	{r4, r5, r6, r7, r8, lr}
 189              	.LCFI3:
 190              		.cfi_remember_state
 191              		.cfi_restore 14
 192              		.cfi_restore 8
 193              		.cfi_restore 7
 194              		.cfi_restore 6
 195              		.cfi_restore 5
 196              		.cfi_restore 4
 197              		.cfi_def_cfa_offset 0
 198 00dc 1EFF2FE1 		bx	lr
 199              	.L12:
 200              	.LCFI4:
 201              		.cfi_restore_state
  38:modes.c       ****     pause(TEN_MS);
 202              		.loc 1 38 5 is_stmt 1 view .LVU35
  38:modes.c       ****     pause(TEN_MS);
 203              		.loc 1 38 40 is_stmt 0 view .LVU36
 204 00e0 0620A0E1 		mov	r2, r6
 205 00e4 0730A0E1 		mov	r3, r7
 206 00e8 030095E8 		ldmia	r5, {r0-r1}
 207 00ec FEFFFFEB 		bl	__aeabi_dmul
 208              	.LVL17:
 209 00f0 FEFFFFEB 		bl	__aeabi_d2iz
 210              	.LVL18:
  38:modes.c       ****     pause(TEN_MS);
 211              		.loc 1 38 5 view .LVU37
 212 00f4 2F10A0E3 		mov	r1, #47
 213 00f8 FF2000E2 		and	r2, r0, #255
 214 00fc 1500A0E3 		mov	r0, #21
 215 0100 FEFFFFEB 		bl	bus_set
 216              	.LVL19:
  39:modes.c       ****   }
 217              		.loc 1 39 5 is_stmt 1 view .LVU38
 218 0104 18009FE5 		ldr	r0, .L14+20
 219 0108 FEFFFFEB 		bl	pause
 220              	.LVL20:
 221 010c E2FFFFEA 		b	.L11
 222              	.L15:
 223              		.align	2
 224              	.L14:
 225 0110 00000000 		.word	register_handler
 226 0114 00000000 		.word	reg8_table
 227 0118 00000000 		.word	.LANCHOR0
 228 011c 0000F83F 		.word	1073217536
 229 0120 80969800 		.word	10000000
 230 0124 A0860100 		.word	100000
 231              		.cfi_endproc
 232              	.LFE1:
 234              		.align	2
 235              		.global	main_mode_loop
 236              		.syntax unified
 237              		.arm
 239              	main_mode_loop:
 240              	.LFB2:
  46:modes.c       **** 
  47:modes.c       **** void main_mode_loop()
  48:modes.c       **** {
 241              		.loc 1 48 1 view -0
 242              		.cfi_startproc
 243              		@ Function supports interworking.
 244              		@ Volatile: function does not return.
 245              		@ args = 0, pretend = 0, frame = 0
 246              		@ frame_needed = 0, uses_anonymous_args = 0
  49:modes.c       ****   reg8_table[REG8_MODE] = IMODE_IDLE;
 247              		.loc 1 49 3 view .LVU40
 248              		.loc 1 49 25 is_stmt 0 view .LVU41
 249 0128 0050A0E3 		mov	r5, #0
  48:modes.c       ****   reg8_table[REG8_MODE] = IMODE_IDLE;
 250              		.loc 1 48 1 view .LVU42
 251 012c 10402DE9 		push	{r4, lr}
 252              	.LCFI5:
 253              		.cfi_def_cfa_offset 8
 254              		.cfi_offset 4, -8
 255              		.cfi_offset 14, -4
 256              		.loc 1 49 25 view .LVU43
 257 0130 1C409FE5 		ldr	r4, .L25
 258              	.L24:
 259 0134 0050C4E5 		strb	r5, [r4]
 260              	.L18:
  50:modes.c       **** 
  51:modes.c       ****   while (1)
 261              		.loc 1 51 3 is_stmt 1 view .LVU44
  52:modes.c       ****   {
  53:modes.c       ****     switch(reg8_table[REG8_MODE])
 262              		.loc 1 53 5 view .LVU45
 263              		.loc 1 53 22 is_stmt 0 view .LVU46
 264 0138 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 265              		.loc 1 53 5 view .LVU47
 266 013c FF3013E2 		ands	r3, r3, #255
 267 0140 FCFFFF0A 		beq	.L18
 268 0144 010053E3 		cmp	r3, #1
 269 0148 F9FFFF1A 		bne	.L24
  54:modes.c       ****     {
  55:modes.c       ****       case IMODE_IDLE:
  56:modes.c       ****         break;
  57:modes.c       ****       case IMODE_MOTOR_DEMO:
  58:modes.c       ****         motor_demo_mode();
 270              		.loc 1 58 9 is_stmt 1 view .LVU48
 271 014c FEFFFFEB 		bl	motor_demo_mode
 272              	.LVL21:
  59:modes.c       ****         break;
 273              		.loc 1 59 9 view .LVU49
 274 0150 F8FFFFEA 		b	.L18
 275              	.L26:
 276              		.align	2
 277              	.L25:
 278 0154 00000000 		.word	reg8_table
 279              		.cfi_endproc
 280              	.LFE2:
 282              		.global	setpoint
 283              		.global	MOTOR_ADDR
 284              		.section	.rodata
 287              	MOTOR_ADDR:
 288 0000 15       		.byte	21
 289              		.bss
 290              		.align	3
 291              		.set	.LANCHOR0,. + 0
 294              	setpoint:
 295 0000 00000000 		.space	8
 295      00000000 
 296              		.text
 297              	.Letext0:
 298              		.file 2 "c:\\arm-gcc\\arm-none-eabi\\include\\machine\\_default_types.h"
 299              		.file 3 "c:\\arm-gcc\\arm-none-eabi\\include\\sys\\_stdint.h"
 300              		.file 4 "../firmware/radio.h"
 301              		.file 5 "../firmware/registers.h"
 302              		.file 6 "../firmware/robot.h"
 303              		.file 7 "../firmware/hardware.h"
 304              		.file 8 "../firmware/sysTime.h"
 305              		.file 9 "../../common/regdefs.h"
DEFINED SYMBOLS
                            *ABS*:00000000 modes.c
C:\Users\agrillo\AppData\Local\Temp\ccJSrNlL.s:22     .text:00000000 $a
C:\Users\agrillo\AppData\Local\Temp\ccJSrNlL.s:26     .text:00000000 register_handler
C:\Users\agrillo\AppData\Local\Temp\ccJSrNlL.s:104    .text:00000058 $d
C:\Users\agrillo\AppData\Local\Temp\ccJSrNlL.s:113    .text:00000068 $a
C:\Users\agrillo\AppData\Local\Temp\ccJSrNlL.s:118    .text:00000068 motor_demo_mode
C:\Users\agrillo\AppData\Local\Temp\ccJSrNlL.s:225    .text:00000110 $d
C:\Users\agrillo\AppData\Local\Temp\ccJSrNlL.s:234    .text:00000128 $a
C:\Users\agrillo\AppData\Local\Temp\ccJSrNlL.s:239    .text:00000128 main_mode_loop
C:\Users\agrillo\AppData\Local\Temp\ccJSrNlL.s:278    .text:00000154 $d
C:\Users\agrillo\AppData\Local\Temp\ccJSrNlL.s:294    .bss:00000000 setpoint
C:\Users\agrillo\AppData\Local\Temp\ccJSrNlL.s:287    .rodata:00000000 MOTOR_ADDR
C:\Users\agrillo\AppData\Local\Temp\ccJSrNlL.s:290    .bss:00000000 $d

UNDEFINED SYMBOLS
__aeabi_ui2f
__aeabi_fmul
__aeabi_f2d
__aeabi_ddiv
__aeabi_dsub
__aeabi_dmul
__aeabi_d2iz
radio_add_reg_callback
init_body_module
start_pid
set_color
bus_set
pause
reg8_table
