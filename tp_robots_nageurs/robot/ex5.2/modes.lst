   1              		.cpu arm7tdmi
   2              		.arch armv4t
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.file	"modes.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.global	__aeabi_ui2f
  18              		.global	__aeabi_fadd
  19              		.global	__aeabi_f2d
  20              		.global	__aeabi_ddiv
  21              		.global	__aeabi_dadd
  22              		.global	__aeabi_d2f
  23              		.global	__aeabi_fcmpgt
  24              		.global	__aeabi_fmul
  25              		.global	__aeabi_dsub
  26              		.global	__aeabi_fcmplt
  27              		.align	2
  28              		.syntax unified
  29              		.arm
  31              	register_handler:
  32              	.LVL0:
  33              	.LFB0:
  34              		.file 1 "modes.c"
   1:modes.c       **** #include "config.h"
   2:modes.c       **** #include "modes.h"
   3:modes.c       **** #include "robot.h"
   4:modes.c       **** #include "module.h"
   5:modes.c       **** #include "registers.h"
   6:modes.c       **** #include "hardware.h"
   7:modes.c       **** 
   8:modes.c       **** volatile float freq = 1.0;   // Hz
   9:modes.c       **** volatile float ampl = 40;
  10:modes.c       **** 
  11:modes.c       **** const uint8_t MOTOR_ADDR = 21;
  12:modes.c       **** 
  13:modes.c       **** 
  14:modes.c       **** 
  15:modes.c       **** /* Register callback function, handles some new registers on the radio.
  16:modes.c       ****  * All these registers are of course completely useless, but it demonstrates how
  17:modes.c       ****  * to implement a register callback function, and what it can do.
  18:modes.c       ****  */
  19:modes.c       **** static int8_t register_handler(uint8_t operation, uint8_t address, RadioData* radio_data)
  20:modes.c       **** {
  35              		.loc 1 20 1 view -0
  36              		.cfi_startproc
  37              		@ Function supports interworking.
  38              		@ args = 0, pretend = 0, frame = 0
  39              		@ frame_needed = 0, uses_anonymous_args = 0
  21:modes.c       ****   switch (operation)
  40              		.loc 1 21 3 view .LVU1
  41 0000 040050E3 		cmp	r0, #4
  42 0004 3900001A 		bne	.L9
  22:modes.c       ****   {
  23:modes.c       ****     case ROP_WRITE_8:
  24:modes.c       ****       if (address == 10) {
  43              		.loc 1 24 7 view .LVU2
  44              		.loc 1 24 10 is_stmt 0 view .LVU3
  45 0008 0A0051E3 		cmp	r1, #10
  20:modes.c       ****   switch (operation)
  46              		.loc 1 20 1 view .LVU4
  47 000c 70402DE9 		push	{r4, r5, r6, lr}
  48              	.LCFI0:
  49              		.cfi_def_cfa_offset 16
  50              		.cfi_offset 4, -16
  51              		.cfi_offset 5, -12
  52              		.cfi_offset 6, -8
  53              		.cfi_offset 14, -4
  54              		.loc 1 24 10 view .LVU5
  55 0010 1600001A 		bne	.L3
  25:modes.c       ****         freq = DECODE_PARAM_8(radio_data->byte,(0),(2));
  56              		.loc 1 25 9 is_stmt 1 view .LVU6
  57              		.loc 1 25 16 is_stmt 0 view .LVU7
  58 0014 0000D2E5 		ldrb	r0, [r2]	@ zero_extendqisi2
  59              	.LVL1:
  60              		.loc 1 25 16 view .LVU8
  61 0018 FEFFFFEB 		bl	__aeabi_ui2f
  62              	.LVL2:
  63              		.loc 1 25 16 view .LVU9
  64 001c 0010A0E1 		mov	r1, r0
  65 0020 FEFFFFEB 		bl	__aeabi_fadd
  66              	.LVL3:
  67 0024 FEFFFFEB 		bl	__aeabi_f2d
  68              	.LVL4:
  69 0028 0020A0E3 		mov	r2, #0
  70 002c C4309FE5 		ldr	r3, .L20
  71 0030 FEFFFFEB 		bl	__aeabi_ddiv
  72              	.LVL5:
  73 0034 0020A0E3 		mov	r2, #0
  74 0038 0030A0E3 		mov	r3, #0
  75 003c FEFFFFEB 		bl	__aeabi_dadd
  76              	.LVL6:
  77 0040 FEFFFFEB 		bl	__aeabi_d2f
  78              	.LVL7:
  26:modes.c       **** 
  27:modes.c       ****         if(freq > 2.0f) freq = 2.0f;
  79              		.loc 1 27 11 view .LVU10
  80 0044 0151A0E3 		mov	r5, #1073741824
  25:modes.c       ****         freq = DECODE_PARAM_8(radio_data->byte,(0),(2));
  81              		.loc 1 25 14 view .LVU11
  82 0048 AC409FE5 		ldr	r4, .L20+4
  83 004c 000084E5 		str	r0, [r4]	@ float
  84              		.loc 1 27 9 is_stmt 1 view .LVU12
  85              		.loc 1 27 11 is_stmt 0 view .LVU13
  86 0050 0510A0E1 		mov	r1, r5
  87              		.loc 1 27 17 view .LVU14
  88 0054 000094E5 		ldr	r0, [r4]	@ float
  89              		.loc 1 27 11 view .LVU15
  90 0058 FEFFFFEB 		bl	__aeabi_fcmpgt
  91              	.LVL8:
  92 005c 000050E3 		cmp	r0, #0
  93              		.loc 1 27 25 is_stmt 1 view .LVU16
  94              		.loc 1 27 30 is_stmt 0 view .LVU17
  95 0060 00508415 		strne	r5, [r4]	@ float
  96              	.L18:
  97              	.LBB4:
  98              	.LBB5:
  28:modes.c       ****         
  29:modes.c       ****         return TRUE;
  30:modes.c       ****       }
  31:modes.c       ****       else if (address == 11) {
  32:modes.c       ****         ampl = DECODE_PARAM_8(radio_data->byte,(-60),(60));
  33:modes.c       **** 
  34:modes.c       ****         if(ampl < -60.0f) ampl = -60.0f;
  35:modes.c       ****         else if(ampl > 60.0f) ampl = 60.0f;
  99              		.loc 1 35 36 view .LVU18
 100 0064 0100A0E3 		mov	r0, #1
 101              	.L2:
 102              	.LBE5:
 103              	.LBE4:
  36:modes.c       **** 
  37:modes.c       ****         return TRUE;
  38:modes.c       ****       }
  39:modes.c       ****   }
  40:modes.c       ****   return FALSE;
  41:modes.c       **** }
 104              		.loc 1 41 1 view .LVU19
 105 0068 7040BDE8 		pop	{r4, r5, r6, lr}
 106              	.LCFI1:
 107              		.cfi_remember_state
 108              		.cfi_restore 14
 109              		.cfi_restore 6
 110              		.cfi_restore 5
 111              		.cfi_restore 4
 112              		.cfi_def_cfa_offset 0
 113 006c 1EFF2FE1 		bx	lr
 114              	.LVL9:
 115              	.L3:
 116              	.LCFI2:
 117              		.cfi_restore_state
  31:modes.c       ****         ampl = DECODE_PARAM_8(radio_data->byte,(-60),(60));
 118              		.loc 1 31 12 is_stmt 1 view .LVU20
  31:modes.c       ****         ampl = DECODE_PARAM_8(radio_data->byte,(-60),(60));
 119              		.loc 1 31 15 is_stmt 0 view .LVU21
 120 0070 0B0051E3 		cmp	r1, #11
  40:modes.c       **** }
 121              		.loc 1 40 10 view .LVU22
 122 0074 0000A013 		movne	r0, #0
 123              	.LVL10:
  31:modes.c       ****         ampl = DECODE_PARAM_8(radio_data->byte,(-60),(60));
 124              		.loc 1 31 15 view .LVU23
 125 0078 FAFFFF1A 		bne	.L2
 126              	.LBB7:
 127              	.LBI4:
  19:modes.c       **** {
 128              		.loc 1 19 15 is_stmt 1 view .LVU24
 129              	.LVL11:
 130              	.LBB6:
  32:modes.c       **** 
 131              		.loc 1 32 9 view .LVU25
  32:modes.c       **** 
 132              		.loc 1 32 16 is_stmt 0 view .LVU26
 133 007c 0000D2E5 		ldrb	r0, [r2]	@ zero_extendqisi2
 134 0080 FEFFFFEB 		bl	__aeabi_ui2f
 135              	.LVL12:
  32:modes.c       **** 
 136              		.loc 1 32 16 view .LVU27
 137 0084 74109FE5 		ldr	r1, .L20+8
 138 0088 FEFFFFEB 		bl	__aeabi_fmul
 139              	.LVL13:
 140 008c FEFFFFEB 		bl	__aeabi_f2d
 141              	.LVL14:
 142 0090 0020A0E3 		mov	r2, #0
 143 0094 5C309FE5 		ldr	r3, .L20
 144 0098 FEFFFFEB 		bl	__aeabi_ddiv
 145              	.LVL15:
 146 009c 0020A0E3 		mov	r2, #0
 147 00a0 5C309FE5 		ldr	r3, .L20+12
 148 00a4 FEFFFFEB 		bl	__aeabi_dsub
 149              	.LVL16:
 150 00a8 FEFFFFEB 		bl	__aeabi_d2f
 151              	.LVL17:
  32:modes.c       **** 
 152              		.loc 1 32 14 view .LVU28
 153 00ac 48409FE5 		ldr	r4, .L20+4
  34:modes.c       ****         else if(ampl > 60.0f) ampl = 60.0f;
 154              		.loc 1 34 11 view .LVU29
 155 00b0 50509FE5 		ldr	r5, .L20+16
  32:modes.c       **** 
 156              		.loc 1 32 14 view .LVU30
 157 00b4 040084E5 		str	r0, [r4, #4]	@ float
  34:modes.c       ****         else if(ampl > 60.0f) ampl = 60.0f;
 158              		.loc 1 34 9 is_stmt 1 view .LVU31
  34:modes.c       ****         else if(ampl > 60.0f) ampl = 60.0f;
 159              		.loc 1 34 11 is_stmt 0 view .LVU32
 160 00b8 0510A0E1 		mov	r1, r5
  34:modes.c       ****         else if(ampl > 60.0f) ampl = 60.0f;
 161              		.loc 1 34 17 view .LVU33
 162 00bc 040094E5 		ldr	r0, [r4, #4]	@ float
  34:modes.c       ****         else if(ampl > 60.0f) ampl = 60.0f;
 163              		.loc 1 34 11 view .LVU34
 164 00c0 FEFFFFEB 		bl	__aeabi_fcmplt
 165              	.LVL18:
 166 00c4 000050E3 		cmp	r0, #0
 167 00c8 0100000A 		beq	.L13
 168              	.L19:
  35:modes.c       **** 
 169              		.loc 1 35 31 is_stmt 1 view .LVU35
  35:modes.c       **** 
 170              		.loc 1 35 36 is_stmt 0 view .LVU36
 171 00cc 045084E5 		str	r5, [r4, #4]	@ float
 172 00d0 E3FFFFEA 		b	.L18
 173              	.L13:
  35:modes.c       **** 
 174              		.loc 1 35 14 is_stmt 1 view .LVU37
  35:modes.c       **** 
 175              		.loc 1 35 16 is_stmt 0 view .LVU38
 176 00d4 30509FE5 		ldr	r5, .L20+20
  35:modes.c       **** 
 177              		.loc 1 35 22 view .LVU39
 178 00d8 040094E5 		ldr	r0, [r4, #4]	@ float
  35:modes.c       **** 
 179              		.loc 1 35 16 view .LVU40
 180 00dc 0510A0E1 		mov	r1, r5
 181 00e0 FEFFFFEB 		bl	__aeabi_fcmpgt
 182              	.LVL19:
 183 00e4 000050E3 		cmp	r0, #0
 184 00e8 DDFFFF0A 		beq	.L18
 185 00ec F6FFFFEA 		b	.L19
 186              	.LVL20:
 187              	.L9:
 188              	.LCFI3:
 189              		.cfi_def_cfa_offset 0
 190              		.cfi_restore 4
 191              		.cfi_restore 5
 192              		.cfi_restore 6
 193              		.cfi_restore 14
  35:modes.c       **** 
 194              		.loc 1 35 16 view .LVU41
 195              	.LBE6:
 196              	.LBE7:
  40:modes.c       **** }
 197              		.loc 1 40 10 view .LVU42
 198 00f0 0000A0E3 		mov	r0, #0
 199              	.LVL21:
 200              		.loc 1 41 1 view .LVU43
 201 00f4 1EFF2FE1 		bx	lr
 202              	.L21:
 203              		.align	2
 204              	.L20:
 205 00f8 00E06F40 		.word	1081073664
 206 00fc 00000000 		.word	.LANCHOR0
 207 0100 0000F042 		.word	1123024896
 208 0104 00004E40 		.word	1078853632
 209 0108 000070C2 		.word	-1032847360
 210 010c 00007042 		.word	1114636288
 211              		.cfi_endproc
 212              	.LFE0:
 214              		.global	__aeabi_fdiv
 215              		.global	__aeabi_dmul
 216              		.global	__aeabi_f2iz
 217              		.global	__aeabi_i2f
 218              		.align	2
 219              		.global	sine_demo_mode
 220              		.syntax unified
 221              		.arm
 223              	sine_demo_mode:
 224              	.LFB1:
  42:modes.c       **** 
  43:modes.c       **** 
  44:modes.c       **** 
  45:modes.c       **** void sine_demo_mode()
  46:modes.c       **** {
 225              		.loc 1 46 1 is_stmt 1 view -0
 226              		.cfi_startproc
 227              		@ Function supports interworking.
 228              		@ args = 0, pretend = 0, frame = 0
 229              		@ frame_needed = 0, uses_anonymous_args = 0
  47:modes.c       ****   uint32_t dt, cycletimer;
 230              		.loc 1 47 3 view .LVU45
  48:modes.c       ****   float my_time, delta_t, l;
 231              		.loc 1 48 3 view .LVU46
  49:modes.c       ****   int8_t l_rounded;
 232              		.loc 1 49 3 view .LVU47
  50:modes.c       **** 
  51:modes.c       ****   cycletimer = getSysTICs();
 233              		.loc 1 51 3 view .LVU48
  46:modes.c       ****   uint32_t dt, cycletimer;
 234              		.loc 1 46 1 is_stmt 0 view .LVU49
 235 0110 F84F2DE9 		push	{r3, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 236              	.LCFI4:
 237              		.cfi_def_cfa_offset 40
 238              		.cfi_offset 3, -40
 239              		.cfi_offset 4, -36
 240              		.cfi_offset 5, -32
 241              		.cfi_offset 6, -28
 242              		.cfi_offset 7, -24
 243              		.cfi_offset 8, -20
 244              		.cfi_offset 9, -16
 245              		.cfi_offset 10, -12
 246              		.cfi_offset 11, -8
 247              		.cfi_offset 14, -4
 248              		.loc 1 51 16 view .LVU50
 249 0114 FEFFFFEB 		bl	getSysTICs
 250              	.LVL22:
 251 0118 0040A0E1 		mov	r4, r0
 252              	.LVL23:
  52:modes.c       ****   my_time = 0;
 253              		.loc 1 52 3 is_stmt 1 view .LVU51
  53:modes.c       **** 
  54:modes.c       ****   init_body_module(MOTOR_ADDR);
 254              		.loc 1 54 3 view .LVU52
 255 011c 1500A0E3 		mov	r0, #21
 256              	.LVL24:
 257              		.loc 1 54 3 is_stmt 0 view .LVU53
 258 0120 FEFFFFEB 		bl	init_body_module
 259              	.LVL25:
  55:modes.c       ****   start_pid(MOTOR_ADDR);
 260              		.loc 1 55 3 is_stmt 1 view .LVU54
 261 0124 1500A0E3 		mov	r0, #21
 262 0128 FEFFFFEB 		bl	start_pid
 263              	.LVL26:
  52:modes.c       ****   my_time = 0;
 264              		.loc 1 52 11 is_stmt 0 view .LVU55
 265 012c 0050A0E3 		mov	r5, #0
  56:modes.c       **** 
  57:modes.c       ****   do {
  58:modes.c       ****     // Calculates the delta_t in seconds and adds it to the current time
  59:modes.c       ****     dt = getElapsedSysTICs(cycletimer);
  60:modes.c       ****     cycletimer = getSysTICs();
  61:modes.c       ****     delta_t = (float) dt / sysTICSperSEC;
 266              		.loc 1 61 13 view .LVU56
 267 0130 18B19FE5 		ldr	fp, .L27
  62:modes.c       ****     my_time += delta_t;
  63:modes.c       **** 
  64:modes.c       ****     // Calculates the sine wave
  65:modes.c       ****     l = ampl * sin(M_TWOPI * freq * my_time);
 268              		.loc 1 65 28 view .LVU57
 269 0134 18819FE5 		ldr	r8, .L27+4
 270 0138 18919FE5 		ldr	r9, .L27+8
 271              	.LVL27:
 272              	.L23:
  57:modes.c       ****     // Calculates the delta_t in seconds and adds it to the current time
 273              		.loc 1 57 3 is_stmt 1 discriminator 1 view .LVU58
  59:modes.c       ****     cycletimer = getSysTICs();
 274              		.loc 1 59 5 discriminator 1 view .LVU59
  59:modes.c       ****     cycletimer = getSysTICs();
 275              		.loc 1 59 10 is_stmt 0 discriminator 1 view .LVU60
 276 013c 0400A0E1 		mov	r0, r4
 277 0140 FEFFFFEB 		bl	getElapsedSysTICs
 278              	.LVL28:
 279 0144 0060A0E1 		mov	r6, r0
 280              	.LVL29:
  60:modes.c       ****     delta_t = (float) dt / sysTICSperSEC;
 281              		.loc 1 60 5 is_stmt 1 discriminator 1 view .LVU61
  60:modes.c       ****     delta_t = (float) dt / sysTICSperSEC;
 282              		.loc 1 60 18 is_stmt 0 discriminator 1 view .LVU62
 283 0148 FEFFFFEB 		bl	getSysTICs
 284              	.LVL30:
  60:modes.c       ****     delta_t = (float) dt / sysTICSperSEC;
 285              		.loc 1 60 18 discriminator 1 view .LVU63
 286 014c 0040A0E1 		mov	r4, r0
 287              	.LVL31:
  61:modes.c       ****     my_time += delta_t;
 288              		.loc 1 61 5 is_stmt 1 discriminator 1 view .LVU64
  62:modes.c       **** 
 289              		.loc 1 62 5 discriminator 1 view .LVU65
  61:modes.c       ****     my_time += delta_t;
 290              		.loc 1 61 15 is_stmt 0 discriminator 1 view .LVU66
 291 0150 0600A0E1 		mov	r0, r6
 292              	.LVL32:
  61:modes.c       ****     my_time += delta_t;
 293              		.loc 1 61 15 discriminator 1 view .LVU67
 294 0154 FEFFFFEB 		bl	__aeabi_ui2f
 295              	.LVL33:
  61:modes.c       ****     my_time += delta_t;
 296              		.loc 1 61 13 discriminator 1 view .LVU68
 297 0158 0B10A0E1 		mov	r1, fp
 298 015c FEFFFFEB 		bl	__aeabi_fdiv
 299              	.LVL34:
 300 0160 0010A0E1 		mov	r1, r0
  62:modes.c       **** 
 301              		.loc 1 62 13 discriminator 1 view .LVU69
 302 0164 0500A0E1 		mov	r0, r5
 303 0168 FEFFFFEB 		bl	__aeabi_fadd
 304              	.LVL35:
 305              		.loc 1 65 14 discriminator 1 view .LVU70
 306 016c E8309FE5 		ldr	r3, .L27+12
  62:modes.c       **** 
 307              		.loc 1 62 13 discriminator 1 view .LVU71
 308 0170 0050A0E1 		mov	r5, r0
 309              	.LVL36:
 310              		.loc 1 65 5 is_stmt 1 discriminator 1 view .LVU72
 311              		.loc 1 65 14 is_stmt 0 discriminator 1 view .LVU73
 312 0174 04A093E5 		ldr	r10, [r3, #4]	@ float
 313              		.loc 1 65 28 discriminator 1 view .LVU74
 314 0178 000093E5 		ldr	r0, [r3]	@ float
 315              	.LVL37:
 316              		.loc 1 65 28 discriminator 1 view .LVU75
 317 017c FEFFFFEB 		bl	__aeabi_f2d
 318              	.LVL38:
 319 0180 0820A0E1 		mov	r2, r8
 320 0184 0930A0E1 		mov	r3, r9
 321 0188 FEFFFFEB 		bl	__aeabi_dmul
 322              	.LVL39:
 323 018c 0060A0E1 		mov	r6, r0
 324              	.LVL40:
 325              		.loc 1 65 16 discriminator 1 view .LVU76
 326 0190 0500A0E1 		mov	r0, r5
 327              		.loc 1 65 28 discriminator 1 view .LVU77
 328 0194 0170A0E1 		mov	r7, r1
 329              		.loc 1 65 16 discriminator 1 view .LVU78
 330 0198 FEFFFFEB 		bl	__aeabi_f2d
 331              	.LVL41:
 332 019c 0020A0E1 		mov	r2, r0
 333 01a0 0130A0E1 		mov	r3, r1
 334 01a4 0600A0E1 		mov	r0, r6
 335 01a8 0710A0E1 		mov	r1, r7
 336 01ac FEFFFFEB 		bl	__aeabi_dmul
 337              	.LVL42:
 338 01b0 FEFFFFEB 		bl	sin
 339              	.LVL43:
 340 01b4 0060A0E1 		mov	r6, r0
 341 01b8 0170A0E1 		mov	r7, r1
 342              	.LVL44:
  66:modes.c       ****     l_rounded = (int8_t) l;
 343              		.loc 1 66 5 is_stmt 1 discriminator 1 view .LVU79
  67:modes.c       **** 
  68:modes.c       ****     bus_set(MOTOR_ADDR, MREG_SETPOINT, DEG_TO_OUTPUT_BODY(l_rounded));
 344              		.loc 1 68 5 discriminator 1 view .LVU80
  65:modes.c       ****     l_rounded = (int8_t) l;
 345              		.loc 1 65 14 is_stmt 0 discriminator 1 view .LVU81
 346 01bc 0A00A0E1 		mov	r0, r10
 347 01c0 FEFFFFEB 		bl	__aeabi_f2d
 348              	.LVL45:
 349 01c4 0730A0E1 		mov	r3, r7
 350 01c8 0620A0E1 		mov	r2, r6
 351 01cc FEFFFFEB 		bl	__aeabi_dmul
 352              	.LVL46:
  65:modes.c       ****     l_rounded = (int8_t) l;
 353              		.loc 1 65 7 discriminator 1 view .LVU82
 354 01d0 FEFFFFEB 		bl	__aeabi_d2f
 355              	.LVL47:
  66:modes.c       ****     l_rounded = (int8_t) l;
 356              		.loc 1 66 15 discriminator 1 view .LVU83
 357 01d4 FEFFFFEB 		bl	__aeabi_f2iz
 358              	.LVL48:
 359              		.loc 1 68 40 discriminator 1 view .LVU84
 360 01d8 000CA0E1 		lsl	r0, r0, #24
 361 01dc 400CA0E1 		asr	r0, r0, #24
 362 01e0 FEFFFFEB 		bl	__aeabi_i2f
 363              	.LVL49:
 364 01e4 FF15A0E3 		mov	r1, #1069547520
 365 01e8 FEFFFFEB 		bl	__aeabi_fmul
 366              	.LVL50:
 367 01ec FEFFFFEB 		bl	__aeabi_f2iz
 368              	.LVL51:
 369              		.loc 1 68 5 discriminator 1 view .LVU85
 370 01f0 2F10A0E3 		mov	r1, #47
 371 01f4 FF2000E2 		and	r2, r0, #255
 372 01f8 1500A0E3 		mov	r0, #21
 373 01fc FEFFFFEB 		bl	bus_set
 374              	.LVL52:
  69:modes.c       ****     
  70:modes.c       ****     // Make sure there is some delay, so that the timer output is not zero
  71:modes.c       ****     pause(ONE_MS);
 375              		.loc 1 71 5 is_stmt 1 discriminator 1 view .LVU86
 376 0200 58009FE5 		ldr	r0, .L27+16
 377 0204 FEFFFFEB 		bl	pause
 378              	.LVL53:
  72:modes.c       **** 
  73:modes.c       ****   } while (reg8_table[REG8_MODE] == IMODE_SINE_DEMO);
 379              		.loc 1 73 11 discriminator 1 view .LVU87
 380              		.loc 1 73 22 is_stmt 0 discriminator 1 view .LVU88
 381 0208 54309FE5 		ldr	r3, .L27+20
 382 020c 0030D3E5 		ldrb	r3, [r3]	@ zero_extendqisi2
 383              		.loc 1 73 3 discriminator 1 view .LVU89
 384 0210 020053E3 		cmp	r3, #2
 385 0214 C8FFFF0A 		beq	.L23
  74:modes.c       ****   bus_set(MOTOR_ADDR, MREG_SETPOINT, DEG_TO_OUTPUT_BODY(0.0));
 386              		.loc 1 74 3 is_stmt 1 view .LVU90
 387 0218 0020A0E3 		mov	r2, #0
 388 021c 2F10A0E3 		mov	r1, #47
 389 0220 1500A0E3 		mov	r0, #21
 390 0224 FEFFFFEB 		bl	bus_set
 391              	.LVL54:
  75:modes.c       ****   pause(ONE_SEC);
 392              		.loc 1 75 3 view .LVU91
 393 0228 38009FE5 		ldr	r0, .L27+24
 394 022c FEFFFFEB 		bl	pause
 395              	.LVL55:
  76:modes.c       ****   bus_set(MOTOR_ADDR, MREG_MODE, MODE_IDLE);
 396              		.loc 1 76 3 view .LVU92
 397 0230 0020A0E3 		mov	r2, #0
 398 0234 2810A0E3 		mov	r1, #40
 399 0238 1500A0E3 		mov	r0, #21
 400 023c FEFFFFEB 		bl	bus_set
 401              	.LVL56:
  77:modes.c       ****   // Back to the "normal" green
  78:modes.c       ****   set_color(2);
 402              		.loc 1 78 3 view .LVU93
 403 0240 0200A0E3 		mov	r0, #2
 404 0244 FEFFFFEB 		bl	set_color
 405              	.LVL57:
  79:modes.c       **** }
 406              		.loc 1 79 1 is_stmt 0 view .LVU94
 407 0248 F84FBDE8 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 408              	.LCFI5:
 409              		.cfi_restore 14
 410              		.cfi_restore 11
 411              		.cfi_restore 10
 412              		.cfi_restore 9
 413              		.cfi_restore 8
 414              		.cfi_restore 7
 415              		.cfi_restore 6
 416              		.cfi_restore 5
 417              		.cfi_restore 4
 418              		.cfi_restore 3
 419              		.cfi_def_cfa_offset 0
 420              	.LVL58:
 421              		.loc 1 79 1 view .LVU95
 422 024c 1EFF2FE1 		bx	lr
 423              	.L28:
 424              		.align	2
 425              	.L27:
 426 0250 8096184B 		.word	1259902592
 427 0254 182D4454 		.word	1413754136
 428 0258 FB211940 		.word	1075388923
 429 025c 00000000 		.word	.LANCHOR0
 430 0260 10270000 		.word	10000
 431 0264 00000000 		.word	reg8_table
 432 0268 80969800 		.word	10000000
 433              		.cfi_endproc
 434              	.LFE1:
 436              		.align	2
 437              		.global	main_mode_loop
 438              		.syntax unified
 439              		.arm
 441              	main_mode_loop:
 442              	.LFB2:
  80:modes.c       **** 
  81:modes.c       **** void main_mode_loop()
  82:modes.c       **** {
 443              		.loc 1 82 1 is_stmt 1 view -0
 444              		.cfi_startproc
 445              		@ Function supports interworking.
 446              		@ Volatile: function does not return.
 447              		@ args = 0, pretend = 0, frame = 0
 448              		@ frame_needed = 0, uses_anonymous_args = 0
  83:modes.c       ****   reg8_table[REG8_MODE] = IMODE_IDLE;
 449              		.loc 1 83 3 view .LVU97
 450              		.loc 1 83 25 is_stmt 0 view .LVU98
 451 026c 0050A0E3 		mov	r5, #0
  82:modes.c       ****   reg8_table[REG8_MODE] = IMODE_IDLE;
 452              		.loc 1 82 1 view .LVU99
 453 0270 10402DE9 		push	{r4, lr}
 454              	.LCFI6:
 455              		.cfi_def_cfa_offset 8
 456              		.cfi_offset 4, -8
 457              		.cfi_offset 14, -4
 458              		.loc 1 83 25 view .LVU100
 459 0274 28409FE5 		ldr	r4, .L37
  84:modes.c       ****   
  85:modes.c       ****   // Registers the register handler callback function
  86:modes.c       ****   radio_add_reg_callback(register_handler);
 460              		.loc 1 86 3 view .LVU101
 461 0278 28009FE5 		ldr	r0, .L37+4
  83:modes.c       ****   
 462              		.loc 1 83 25 view .LVU102
 463 027c 0050C4E5 		strb	r5, [r4]
 464              		.loc 1 86 3 is_stmt 1 view .LVU103
 465 0280 FEFFFFEB 		bl	radio_add_reg_callback
 466              	.LVL59:
 467              	.L31:
  87:modes.c       **** 
  88:modes.c       ****   while (1)
 468              		.loc 1 88 3 view .LVU104
  89:modes.c       ****   {
  90:modes.c       ****     switch(reg8_table[REG8_MODE])
 469              		.loc 1 90 5 view .LVU105
 470              		.loc 1 90 22 is_stmt 0 view .LVU106
 471 0284 0030D4E5 		ldrb	r3, [r4]	@ zero_extendqisi2
 472              		.loc 1 90 5 view .LVU107
 473 0288 FF3013E2 		ands	r3, r3, #255
 474 028c FCFFFF0A 		beq	.L31
 475 0290 020053E3 		cmp	r3, #2
  91:modes.c       ****     {
  92:modes.c       ****       case IMODE_IDLE:
  93:modes.c       ****         break;
  94:modes.c       ****       case IMODE_SINE_DEMO:
  95:modes.c       ****         sine_demo_mode();
  96:modes.c       ****         break;
  97:modes.c       ****       default:
  98:modes.c       ****         reg8_table[REG8_MODE] = IMODE_IDLE;
 476              		.loc 1 98 31 view .LVU108
 477 0294 0050C415 		strbne	r5, [r4]
  90:modes.c       ****     {
 478              		.loc 1 90 5 view .LVU109
 479 0298 F9FFFF1A 		bne	.L31
  95:modes.c       ****         break;
 480              		.loc 1 95 9 is_stmt 1 view .LVU110
 481 029c FEFFFFEB 		bl	sine_demo_mode
 482              	.LVL60:
  96:modes.c       ****       default:
 483              		.loc 1 96 9 view .LVU111
 484 02a0 F7FFFFEA 		b	.L31
 485              	.L38:
 486              		.align	2
 487              	.L37:
 488 02a4 00000000 		.word	reg8_table
 489 02a8 00000000 		.word	register_handler
 490              		.cfi_endproc
 491              	.LFE2:
 493              		.global	MOTOR_ADDR
 494              		.global	ampl
 495              		.global	freq
 496              		.section	.rodata
 499              	MOTOR_ADDR:
 500 0000 15       		.byte	21
 501              		.data
 502              		.align	2
 503              		.set	.LANCHOR0,. + 0
 506              	freq:
 507 0000 0000803F 		.word	1065353216
 510              	ampl:
 511 0004 00002042 		.word	1109393408
 512              		.text
 513              	.Letext0:
 514              		.file 2 "c:\\arm-gcc\\arm-none-eabi\\include\\machine\\_default_types.h"
 515              		.file 3 "c:\\arm-gcc\\arm-none-eabi\\include\\sys\\_stdint.h"
 516              		.file 4 "../firmware/radio.h"
 517              		.file 5 "../firmware/registers.h"
 518              		.file 6 "../firmware/sysTime.h"
 519              		.file 7 "../firmware/robot.h"
 520              		.file 8 "../firmware/hardware.h"
 521              		.file 9 "../../common/regdefs.h"
 522              		.file 10 "c:\\arm-gcc\\arm-none-eabi\\include\\math.h"
DEFINED SYMBOLS
                            *ABS*:00000000 modes.c
C:\Users\agrillo\AppData\Local\Temp\ccZUvATN.s:27     .text:00000000 $a
C:\Users\agrillo\AppData\Local\Temp\ccZUvATN.s:31     .text:00000000 register_handler
C:\Users\agrillo\AppData\Local\Temp\ccZUvATN.s:205    .text:000000f8 $d
C:\Users\agrillo\AppData\Local\Temp\ccZUvATN.s:218    .text:00000110 $a
C:\Users\agrillo\AppData\Local\Temp\ccZUvATN.s:223    .text:00000110 sine_demo_mode
C:\Users\agrillo\AppData\Local\Temp\ccZUvATN.s:426    .text:00000250 $d
C:\Users\agrillo\AppData\Local\Temp\ccZUvATN.s:436    .text:0000026c $a
C:\Users\agrillo\AppData\Local\Temp\ccZUvATN.s:441    .text:0000026c main_mode_loop
C:\Users\agrillo\AppData\Local\Temp\ccZUvATN.s:488    .text:000002a4 $d
C:\Users\agrillo\AppData\Local\Temp\ccZUvATN.s:499    .rodata:00000000 MOTOR_ADDR
C:\Users\agrillo\AppData\Local\Temp\ccZUvATN.s:510    .data:00000004 ampl
C:\Users\agrillo\AppData\Local\Temp\ccZUvATN.s:506    .data:00000000 freq
C:\Users\agrillo\AppData\Local\Temp\ccZUvATN.s:502    .data:00000000 $d

UNDEFINED SYMBOLS
__aeabi_ui2f
__aeabi_fadd
__aeabi_f2d
__aeabi_ddiv
__aeabi_dadd
__aeabi_d2f
__aeabi_fcmpgt
__aeabi_fmul
__aeabi_dsub
__aeabi_fcmplt
__aeabi_fdiv
__aeabi_dmul
__aeabi_f2iz
__aeabi_i2f
getSysTICs
init_body_module
start_pid
getElapsedSysTICs
sin
bus_set
pause
set_color
reg8_table
radio_add_reg_callback
